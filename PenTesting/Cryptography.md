# Cryptography

`Plaintext`: The original, readable message or data before encryption. Examples include documents, images, or multimedia files.  
`Ciphertext`: The scrambled, unreadable version of the message after encryption. It reveals no information about the plaintext other than its approximate size.  
`Cipher`: The algorithm or method used to convert plaintext to ciphertext and vice versa. It is generally developed by mathematicians.  
`Key`: A secret string of bits used by the cipher to encrypt or decrypt data. The cipher is public knowledge, but the key must remain private (except for public keys in asymmetric encryption).  
`Encryption`: The process of converting plaintext into ciphertext using a cipher and a key. The cipher is disclosed, but the key is not.  
`Decryption`: The reverse process of encryption, converting ciphertext back to plaintext using a cipher and a key. Without the key, recovering the plaintext should be infeasible.  

## Types of Encryption
`Symmetric encryption (or symmetric cryptography)` uses the same key for both encryption and decryption.  
The key must remain secret, making secure communication of the key a significant challenge.  
Sharing the key securely, especially in the presence of potential threats like industrial espionage, is difficult. 
For example, you can encrypt a document and email it to a colleague, but sharing the password over email is unsafe.  
A secure channel, such as an in-person meeting, may be necessary to share the key safely.

![img.png](img/img_7.png)

Examples of symmetric encryption: DES, 3DES, and AES.  
`DES (Data Encryption Standard)`: Adopted in 1977, uses a 56-bit key. It became insecure as computing power advanced, with a key broken in under 24 hours by 1999.  
`3DES (Triple DES)`: An interim solution applying DES three times, with a 168-bit key (effective security: 112 bits). Deprecated in 2019, but still present in some legacy systems.  
`AES (Advanced Encryption Standard)`: Adopted in 2001 with key sizes of 128, 192, or 256 bits. It is the recommended standard today.


`Asymmetric encryption (public key cryptography)` uses two keys—a public key to encrypt data and a private key to decrypt it. 
The private key must remain secret. Examples: `RSA`, `Diffie-Hellman`, and `Elliptic Curve Cryptography (ECC)`.
More secure but slower than symmetric encryption.
Based on mathematical problems that are easy to compute in one direction but practically infeasible to reverse (e.g., would take millions of years to solve with current technology).
Key sizes:  
`RSA and Diffie-Hellman`: Minimum recommended key size is 2048 bits, with 3072-bit and 4096-bit keys offering enhanced security.
`ECC`: Provides equivalent security with shorter keys (e.g., a 256-bit ECC key matches the security of a 3072-bit RSA key).
Advantages and disadvantages:

![img_1.png](img/img_8.png)

`Hybryd encryption`: asymmetric + symmetric. Use asymmetric to facilitate a key exchange of secret key used for symmetric encryption for data.

## Basic Math (XOR and Modulo)
The `XOR (Exclusive OR`) operation is a logical operation that outputs true (or 1) if and only if the inputs are different. 
If the inputs are the same, the output is false (or 0). It’s widely used in digital electronics, computer science, 
and programming.  
XOR is typically represented by the symbol ⊕ or ^ (caret) in programming.

| Input A | Input B | Output A ⊕ B |
|---------|---------|--------------|
| 0 | 0 | 0
| 0 | 1 | 1
| 1 | 0 | 1
| 1 | 1 | 0

Key Properties of XOR:  
`Self-Inverse`: A ⊕ A = 0  
XOR-ing a number with itself always results in 0.  
`Identity`: A ⊕ 0 = A  
XOR-ing a number with 0 leaves it unchanged.  
`Commutative`: A ⊕ B = B ⊕ A  
The order of the inputs doesn't matter.  
`Associative`: A ⊕ (B ⊕ C)=(A ⊕ B) ⊕ C  
Grouping doesn’t matter in sequences of XOR operations.  
`Bitwise Operation`: XOR works bit by bit in binary numbers.  

Example: XORing binary values 1010 and 1100 yields 0110.  

Use in cryptography:
XOR is a key operation in symmetric encryption.  
Encryption: C= P ⊕ K (ciphertext = plaintext XOR key).  
Decryption: P = C ⊕ K, as (P ⊕ K) ⊕ K= P.
A secret key as long as the plaintext is required in practice.

The `modulo operator (% or mod)` gives the remainder when one number (X) is divided by another (Y). 
In cryptography, this remainder is more important than the quotient. For example:
25%5 = 0 (remainder is 0)  
23%6 = 5 (remainder is 5)  
23%7 = 2 (remainder is 2)  
When working with large numbers in cryptography, programming languages like Python can handle them easily, 
as they support big integers.  
The modulo operation always returns a result between 0 and one less than the divisor, but it’s not reversible.  
If x%5 = 4, there are infinite possible values for x.

## RSA
RSA encryption relies on the difficulty of factoring large numbers. 
While multiplying two large prime numbers is easy, factoring their product is computationally challenging. 
For example, multiplying primes like 113 × 127 gives 14351, and even larger primes can be multiplied manually.  
However, when you multiply very large primes, like 982451653031 and 169743212279, the result is a huge number (166764499494295486767649), 
making factoring it much more difficult. This difficulty is the basis of RSA's security.

RSA creates a pair of "commutative" keys, encrypt with one decrypt with the other. 

Factor = numbers you can multiply to get original number. Factors of 12: 1,2,3,4,6,12  
Prime = numbers whose factors are only 1 and itself Factors of  7 = 1,7  
Semi-Prime = Numbers whose factors are prime numbers Factors of 21: 1,3,7,21 Product of two primes is always Semi Prime  
Modulo = remainder division 13 mod 5 = 3

RSA Example:
1. Generate Keys: 
- Select two Prime Numbers (P,Q)  
- Calculate Product (N=P*Q)  
- Calculate Totien(to trudna rzecz po prostu wez tak jak jest) T = (P-1)*(Q-1)  
- Select Public Key (E) for example will be 29, must match three condition: must be prime, must be less than Totient, must not be a factor of Totient  
- Select a Private Key (D) for example here 41, one condition: product of D and E, divided by T must result in reminder of 1
2. Encryption and Decryption:
- Encryption: Message^E MOD N = Cipher text
- Decryption: Cipher^D MOD N = Message

## Diffie-Hellman Key Exchange
Allows two parties to establish a shared secret over an unsecured medium.

Alice and Bob  what they do:
1. Agree upon two numbers `P` prime number ex: 13 and `G` generator of `P` ex: 6
2. Randomly Generate a Private Key ex: Alice = 5  Bob = 4
3. Calculate the public key (G^Private) MOD P so  Alice = 2 and Bob = 9
4. Now Alice and Bob exchange their public values anyone listening on the public wire will now what these values are
5. Calculate the Shared Secret (Shared Public^Private) MOD P

![img_2.png](img/img_9.png)

___
## Sources
- tryhackme, Cryptography Basics, https://tryhackme.com/r/room/cryptographybasics.
- tryhackme, Public Key Cryptography Basics, https://tryhackme.com/r/room/publickeycrypto.
- Practical Networking, RSA Algorithm - How does it work? - I'll PROVE it with an Example! -- Cryptography - Practical TLS, https://www.youtube.com/watch?v=Pq8gNbvfaoM&t=10s&ab_channel=PracticalNetworking.
- Practical Networking, Diffie-Hellman Key Exchange - the MAGIC that makes it possible - Cryptography - Practical TLS, https://www.youtube.com/watch?v=KXq065YrpiU&ab_channel=PracticalNetworking.